#!/usr/bin/env ruby

Thread.abort_on_exception = true

class Monitor
    @monitors = []
    @monitors_by_name = {}

    def self.add(instance)
        @monitors << instance
        @monitors_by_name[instance.name] = instance
    end

    def self.[](n)
        case n
        when Integer
            @monitors[n]
        when String
            @monitors_by_name[n]
        end
    end

    def self.all
        @monitors
    end

    def self.each
        @monitors.each { |m| yield m }
    end

    def initialize(name, res, pos)
        @name = name
        @res = res.split 'x', 2
        @pos = pos.split '+', 2

        @res.map!(&:to_i)
        @pos.map!(&:to_i)

        @desktops = []

        Monitor.add self

        # Rely on the 1-1, 1-2, 2-1, 2-2 desktop naming convention (monitor-desktop)
        @order = `bspc query -m "#{name}" -D`[0].to_i - 1 # WARNING: FRAGILE (please work ;-;)

        create_panel
    end

    %i| primary secondary tertiary quaternary quinary senary septenary octonary nonary denary |
    .each_with_index do |name, index|
        name_question = :"#{name}?"

        define_singleton_method(name) { @monitors.find{ |n| n.send name_question } }
        define_singleton_method(name_question) { @monitors.any?{ |n| n.send name_question } }
        define_method(name_question) { @order == index }
    end

    def create_panel
        @panel ||= Panel.new self
    end

    def active_window
        `bspc query -m "#{name}" -T`
            .lines                          # Split output by lines
            .drop(1)                        # Drop the monitor line
            .slice_before(/^\t\S/)          # Split by desktops
            .find{ |n| n.first[/\*$/] }     # Find the active desktop
            .drop(1)                        # Drop the desktop line
            .find{ |n| n[/\*$/] }           # Find the active window
            .split[3]                       # Get the window ID
    end

    attr_accessor :active
    attr_reader :panel, :name, :desktops
    def x; @pos[0] end
    def y; @pos[1] end
    def w; @res[0] end
    def h; @res[1] end

    def to_s
        "Monitor #{@name} #{@res.join 'x'} #{@pos.join '+'}"
    end
end

module Notifications
    @notifications = []

    def self.run
        @statnot = open '|statnot /dev/stdin', 'r+'
        @statnot.puts <<-EOF.gsub(/^ {12}/, '') # please python :<
            import sys
            MAX_NOTIFY_TIMEOUT = 1
            DEFAULT_NOTIFY_TIMEOUT = 1
            USE_STATUSTEXT = False
            def update_text(text):
                print(text)
                sys.stdout.flush()
        EOF
        @statnot.close_write

        Thread.new do
            @statnot.each_line do |n|
                push Notification.new(*n.chomp.split(' ', 2))
                Monitor.primary.panel.update
            end
        end

        Thread.new do
            loop do
                sleep 1

                next if last.nil?

                last.timeout -= 1
                if last.timeout <= 0
                    pop
                end
            end
        end
    end

    def self.push(n)
        @notifications << n
    end

    def self.pop
        @notifications.pop
    end

    def self.last
        @notifications.last
    end
end

Notification = Struct.new :title, :body do
    attr_accessor :timeout

    def initialize(*args)
        super(*args)

        @timeout = 5
    end

    def render
        "#{title} #{body}"
    end
end

class Panel
    def initialize(monitor)
        @height = `bspc config -m "#{monitor.name}" bottom_padding`.to_i

        @monitor = monitor
        @bar = open "|lemonbar -g #{monitor.w}x#{@height}+#{monitor.x}+#{monitor.y + monitor.h - @height}" +
                             " -f 'Droid Sans Mono:size=8'" +
                             " -f '-wuncon-siji-medium-r-normal--10-100-75-75-c-80-iso10646-1'" +
                             " -B '#e61d1f21' -o 1", 'w+'

        @bar_read_thread = Thread.new do
            @bar.each_line{ |n| system n.chomp }
        end

        @drawing = false
    end

    def space(n)
        draw " " * n
    end

    def align(where)
        draw "%{#{where.to_s[0]}}"
    end

    def desktops
        draw '%{A4:bspc desktop -f prev:}'
        draw '%{A5:bspc desktop -f next:}'
        draw @monitor.desktops.map{ |name, color| "%{A:bspc desktop -f #{name}:}%{F#{color}}î„„ %{A}" }.join
        draw '%{A}%{A}'
    end

    def active_window_title
        draw "%{F#efefef}#{`xtitle #{@monitor.active_window}` rescue ''}"
    end

    def time
        draw Time.now.strftime '%H:%M'
    end

    def notifications
        draw Notifications.last.render rescue nil
    end

    def now_playing
        draw ''
    end

    def update
        return if @drawing
        @drawing = true
        space 2

        desktops
        space 1
        active_window_title

        align :center
        space 5

        notifications if @monitor.primary?
        now_playing if @monitor.secondary?

        space 5
        align :right

        time

        space 2
        @bar.write "\n"
        @drawing = false
    end

    private

    def draw(stuff)
        @bar.write stuff.gsub "\n", ''
    end
end


`bspc query -T`.scan(/^\S.*$/) do |m|
    /(?<name>\S+) (?<size>\d+x\d+)\+(?<pos>\d+\+\d+)/ =~ m
    Monitor.new name, size, pos
end

Notifications.run


threads = []

# Update every second
threads << Thread.new{ loop{ sleep 1; Monitor.each{ |n| n.panel.update } } }

# Desktops
threads << Thread.new do
    bspc = open '|bspc control --subscribe window', 'r'
    bspc.each_line do |line|
        case line[0]
        when 'W'
            monitor = nil

            line[1..-1].split(':').each do |item|
                name = item[1..-1]

                case item[0]
                when 'M', 'm'
                    monitor = Monitor[name]
                    monitor.active = item[0] == 'M'
                    monitor.desktops.clear
                when 'L' # layout; end of desktops
                    monitor.panel.update
                else
                    colors = {
                        'O' => '#edeff1', # occupied active
                        'F' => '#5d5f61', # free active
                        'o' => '#7d7f81', # occupied inactive
                        'f' => '#3d3f41', # free inactive
                        'u' => '#ffaf00', # urgent
                        'U' => '#ffaf00'
                    }

                    monitor.desktops << [ name, colors[item[0]] ]
                end
            end
        end
    end
end

sleep
